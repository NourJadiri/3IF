---
title: "TP"
output: html_notebook
---
This is an [R Markdown](http://rmarkdown.rstudio.com) Notebook. When you execute code within the notebook, the results appear beneath the code. 

Try executing this chunk by clicking the *Run* button within the chunk or by placing your cursor inside it and pressing *Ctrl+Shift+Enter*. 

```{r}
plot(cars)
```

Add a new chunk by clicking the *Insert Chunk* button on the toolbar or by pressing *Ctrl+Alt+I*.

When you save the notebook, an HTML file containing the code and output will be saved alongside it (click the *Preview* button or press *Ctrl+Shift+K* to preview the HTML file).

The preview shows you a rendered HTML copy of the contents of the editor. Consequently, unlike *Knit*, *Preview* does not run any R code chunks. Instead, the output of the chunk when it was last run in the editor is displayed.


# Congruence Lineaire

On implémente un algorithme générique pour générateur à congruence linéaire

## Question 1

---
```{r}
congruenceLineaire <- function(graine , a , b , m , n){
  seed <- rep(graine,n)
  
  for(i in 2:n){
    seed[i] <- (a*seed[i-1] + b)%%m
  }
  
  return (seed)
}
```

### RANDU
---
```{r}
RANDU <- function(graine = 69420 , n){
  a <- 65539
  b <- 0
  m <- 2^31
  return (congruenceLineaire(graine, a , b , m , n))
}
```


### Standard Minimal
```{r}
standardMinimal <- function(graine = 69420, n){
  a <- 16807
  b <- 0
  m <- 2^31 - 1
  
  return (congruenceLineaire(graine , a , b , m , n))
}
```

### VonNeumann
```{r}
VonNeumann <- function(n, p=1, graine)
{
  x <-  rep(graine,n*p+1)
  for(i in 2:(n*p+1))
  {
    numbers <- strsplit(format(x[i-1]^2,scientific=FALSE),'')[[1]]
    while(length(numbers)>4){ 
        numbers <- numbers[2:(length(numbers)-1)] 
    }
    x[i] <- as.numeric(numbers)%*%(10^seq(length(numbers)-1,0,-1))
  }
  x <- matrix(x[2:(n*p+1)],nrow=n,ncol=p)
  return(x)
}

```

### Mersenne-Twister
```{r}
MersenneTwister <- function(n, p=1, graine)
{
  set.seed(graine,kind='Mersenne-Twister')
  x <- sample.int(2^32-1,n*p)
  x <- matrix(x,nrow=n,ncol=p)
  return(x)
}

```

## Question 2

### 2.1

#### RANDU

```{r}
testStatistiques <- function(k) {
  par(mfrow = c(2,2))
  hist(RANDU(graine = 215, n = k) , xlab = "Valeur" , ylab = "fréquence" , main = "RANDU")
  hist(standardMinimal(graine = 215 , n = k) , xlab = "Valeur" , ylab = "fréquence" , main = "Standard Minimal")
  hist(VonNeumann(n = k , graine = 215), main = "Von Neumann")
  hist(MersenneTwister(n = k, graine = 215), main = "Mersenne-Twister") 
}

```

```{r}
testStatistiques(100)
```

### 2.2

#### S(n) = f(S(n-1))
On trace $S_n = f(S_{n-1})$
```{r}
n = 100
u_RANDU <- RANDU(graine = 215, n =100) 
u_SM <- standardMinimal(graine = 215, n =100) 
u_VonNeumann <- VonNeumann(n = 100, graine = 215)
u_MersenneTwister <- MersenneTwister(n = 100 , graine = 215)


plot(u_RANDU[1:(n-1)] , u_RANDU[2:n] , xlab = "S(n-1)" , ylab = "(S_n)", main = "RANDU")
plot(u_SM[1:(n-1)] , u_SM[2:n] , xlab = "S(n-1)" , ylab = "(S_n)" , main = "Standard Minimal")
plot(u_VonNeumann[1:(n-1)] , u_VonNeumann[2:n] , xlab = "S(n-1)" , ylab = "(S_n)", main = "von Neumann")
plot(u_MersenneTwister[1:(n-1)] , u_MersenneTwister[2:n] , xlab = "S(n-1)" , ylab = "(S_n)" , main = "Mersenne-Twister")
```
La représentation graphique montre comment chaque nombre dans la séquence générée dépend de son prédécesseur. Plus précisément, les coordonnées $S_{n-1}~,~ S_n$ pour chaque n représentent les points dans un nuage de points. Les coordonnées correspondent aux valeurs des nombres aléatoires générés, où `S(n-1)` est la valeur de l'élément précédent dans la séquence et $Sn$ est la valeur actuelle.

Si on se contente d'observer $S_n = f(S_{n-1})$ alors on peut penser que la génération se fait de manière aléatoire, cependant, le seed donné initialement détermine toujours la output de l'algortithme à un certain ordre N.

En d'autres termes, la méthode RANDU a des propriétés qui peuvent entraîner une apparence aléatoire des points dans le nuage de points, même si les nombres générés ne sont pas vraiment aléatoires. Par exemple, les points peuvent sembler être répartis de manière uniforme sur le graphique, même si des motifs répétitifs existent.

## Test de fréquence monobit

```{r}
binary <- function(x)
{
  if((x<2^31)&(x>=0))
    return( as.integer(intToBits(as.integer(x))) )
  else{
    if((x<2^32)&(x>0))
      return( c(binary(x-2^31)[1:31], 1) )
    else{
      cat('Erreur dans binary : le nombre etudie n est pas un entier positif en 32 bits.\n')
      return(c())
    }
  }
}

```


### Implémentation
On commence par implémenter la fonction de calcul du nombre de bits à 1

```{r}
Frequency <- function(x , nb = 32){

  binarySequence <- sapply(x , binary)

  binarySequence <- binarySequence[1 : nb,]
  
  bb <- matrix(binarySequence, nrow = nb*length(x))
  
  r <- sum(2*bb[1:length(bb)] - 1)
  
  s_obs <- abs(r)/sqrt(nb*length(x))
  
  p_value <- 2 * (1 - pnorm(s_obs))
  
  return (p_value)
}

Frequency2 <- function(x,nb){
  s <- rep(0,length(x))
  for(i in 1:length(x)){
    bSeq <- binary(x[i])[1:nb]
    s[i] <- sum(2 * bSeq[1:nb] - 1)
  }
  
  s_obs <- abs(sum(s))/sqrt(nb * length(x))
  
  p_value <- 2 * (1 - pnorm(s_obs))
  
  return (p_value)
}
```

### Tests
```{r}

set.seed(555)

u1 <- sample.int(10000 , 100)
freq_RANDU <- c()
freq_SM <- c()
freq_VonNeumann <- c()
freq_MersenneTwister <- c()

for(i in 1:length(u1)){
  u_RANDU <- RANDU(graine = u1[i], n = 200)
  u_SM <- standardMinimal(graine = u1[i] , n = 200)
  u_VonNeumann <- VonNeumann(graine = u1[i] , n = 200)
  u_MersenneTwister <- MersenneTwister(graine = u1[i] , n = 200)
  freq_RANDU <- c(freq_RANDU,Frequency(u_RANDU , 31))
  freq_SM <- c(freq_SM,Frequency(u_SM , 31))
  freq_VonNeumann <- c(freq_VonNeumann,Frequency(u_VonNeumann , 14))
  freq_MersenneTwister <- c(freq_MersenneTwister,Frequency(u_MersenneTwister))
}

# Nombre de valeurs inferieures à 0.01
n_RANDU <- length(which(freq_RANDU < 0.01))
n_SM <- length(which(freq_SM < 0.01))
n_VonNeumann <- length(which(freq_VonNeumann < 0.01))
n_MersenneTwister <- length(which(freq_MersenneTwister < 0.01))
```


On remarque que Mersenne-Twister et StandardMinimal ont de bien meilleures performances que les autres algorithmes. Cela vient confirmer la distribution qu'on a plot plus haut, qui montre que les distributions de ces deux algorithmes sont celles qui se rapprochent le plus d'une loi uniforme.





